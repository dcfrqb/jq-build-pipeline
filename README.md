# Система сборки проекта jq

## Описание

Локальный конвейер сборки проекта jq в Docker контейнере. Конвейер поддерживает три режима сборки: Release, Debug и Coverage. Проект jq используется как демонстрационный объект сборки - архитектура конвейера не зависит от конкретного проекта.

jq — это легковесная утилита командной строки для парсинга, фильтрации и преобразования данных в формате JSON.

В пакете бинарник размещается в /usr/bin для соответствия стандартному расположению CLI-утилит.

## Требования

- **Docker** - для сборки и запуска контейнера
- **Bash** - для выполнения скриптов (обычно предустановлен)

## Как запустить

Конвейер запускается одной командой:

```bash
./build.sh [release|debug|coverage]
```

### Примеры запуска

```bash
# Сборка в режиме Release
./build.sh release

# Сборка в режиме Debug
./build.sh debug

# Сборка в режиме Coverage
./build.sh coverage
```

При первом запуске Docker образ будет собран автоматически. При последующих запусках используется существующий образ.

## Режимы сборки

### Release
- Оптимизации компилятора (`-O2`)
- Удаление отладочной информации (strip)
- Создание deb-пакета с номером ревизии
- Артефакты: `artifacts/release/`

### Debug
- Отладочные символы (`-g`)
- Сохранение отладочной информации (без strip)
- Создание deb-пакета с номером ревизии
- Артефакты: `artifacts/debug/`

### Coverage
- Инструменты gcov/lcov для анализа покрытия кода
- Интеграционное тестирование (`jq --version`)
- Проверка динамики покрытия по сравнению с предыдущим запуском
- Генерация отчета о покрытии
- Артефакты: `artifacts/coverage/`

**Важно:** В режиме Coverage сборка завершится с ошибкой, если покрытие кода уменьшилось по сравнению с предыдущим запуском.

## Структура проекта

```
Тестовое задание/
├── build.sh                # Главный скрипт конвейера
├── Dockerfile              # Образ для сборки
├── CONTEXT.md              # Контекст и допущения
├── README.md               # Этот файл
├── scripts/
│   ├── build-release.sh    # Сборка Release
│   ├── build-debug.sh      # Сборка Debug
│   ├── build-coverage.sh   # Сборка Coverage
│   ├── package-deb.sh      # Создание deb-пакета
│   ├── generate-report.sh  # Генерация отчета
│   └── utils.sh            # Вспомогательные функции
├── artifacts/              # Артефакты сборки
│   ├── release/            # Release артефакты и deb-пакеты
│   ├── debug/              # Debug артефакты и deb-пакеты
│   └── coverage/           # Coverage артефакты и отчеты
└── reports/                # Отчеты о сборке
    └── build_report_*.txt  # Отчеты с информацией о сборке
```

## Артефакты

### Release и Debug
- Собранный бинарник `jq` в `artifacts/<режим>/usr/local/bin/jq`
- deb-пакет: `jq-<режим>_<версия>-<ревизия>_<архитектура>.deb`
- Имя пакета содержит номер ревизии (git hash или timestamp)

### Coverage
- Собранный бинарник `jq` в `artifacts/coverage/usr/local/bin/jq`
- Отчет о покрытии: `artifacts/coverage/coverage_<ревизия>.txt`
- Файл lcov: `artifacts/coverage/coverage_<ревизия>.info`

## Отчеты

После каждой сборки создается отчет в директории `reports/`:
- Имя файла: `build_report_<дата>_<время>.txt`
- Формат: `build_report_YYYYMMDD-HHMMSS.txt`
- Содержит:
  - Номер запуска (инкрементальный)
  - Ревизию (git hash или timestamp)
  - Тип сборки (release/debug/coverage)
  - Покрытие кода (для coverage, иначе N/A)

## Примечания об упрощениях (junior-уровень)

Решение реализовано на уровне junior DevOps с осознанными упрощениями:

1. **Coverage динамика:**
   - Простое сравнение с предыдущим запуском через файл
   - Без сложной системы хранения истории

2. **Интеграционное тестирование:**
   - Простой тест `jq --version` для демонстрации работы инструментов
   - Без полноценного набора тестов

3. **deb-пакеты:**
   - Минимальная структура пакета
   - Только deb (без rpm)
   - Базовые метаданные

4. **Обработка ошибок:**
   - Базовые проверки без избыточной валидации
   - Понятные сообщения об ошибках

5. **Архитектура:**
   - Простая структура без избыточных абстракций
   - Прямолинейная логика без усложнений

## Автоматизация

- Docker образ собирается автоматически при первом запуске
- Ревизия определяется автоматически (git hash или timestamp)
- Номер запуска инкрементируется автоматически
- Отчеты генерируются автоматически после каждой сборки

